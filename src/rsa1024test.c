#include "rsa1024test.h"


#define SUCCESS 0
#define FAIL -1

#define RSA_NUM_BITS 1024
#define RSA_NUM_BYTES 128

#define PRINTARGS 1


// device structs
XWsrsa1024 xrsamodexp;
XWsrsa1024_Config *xrsamodexpCfgPtr;

// Mode
typedef enum {ENCRYPT=0, DECRYPT=1, DECRYPTINITKEY=2} RSAMode_t;

// test data
uint8_t golden_ans = 0x1D;
//uint8_t M[] = {0x99,0xed,0xc7,0x29,0xfc,0xac,0xff,0xd1,0x27,0x91,0xc6,0xfc,0xa9,0xbb,0xf0,0xa2,0xef,0x94,0xeb,0x30,0x30,0x62,0x79,0xd1,0x24,0x75,0x25,0xe5,0xd9,0x1c,0x99,0xdd,0x9e,0xc2,0x5d,0x8c,0xcd,0x5f,0x4d,0x32,0xa4,0xde,0xb7,0xad,0x86,0x92,0x7e,0xc4,0xb9,0x05,0x85,0x77,0x05,0x84,0x23,0x84,0xeb,0xc4,0x5a,0xc2,0x5f,0x57,0x1e,0x4f,0xbd,0xc0,0x70,0x22,0x2e,0x8d,0xbf,0x47,0xcc,0x47,0x1a,0xac,0x7d,0x52,0xd4,0x90,0x01,0x6e,0x1a,0x97,0xf5,0xd9,0xc5,0x85,0xf8,0x89,0x8b,0x16,0x55,0xcd,0xfa,0x0a,0xdc,0x32,0x2e,0xe2,0x85,0x1e,0xd7,0x14,0x65,0x29,0xfe,0x74,0xf7,0x1b,0xb7,0x5b,0x34,0x69,0xf8,0xb5,0xd1,0x94,0x7b,0x55,0x48,0xc3,0x52,0x64,0x0a,0x0a,0x0c,0xe0};
//uint8_t e[] = {0x10,0x02,0x0c,0xf1,0x9d,0xd8,0x7c,0x07,0x50,0x32,0x1f,0x7f,0x94,0xb6,0xbc,0x04,0xc2,0xad,0x82,0x28,0x63,0x8f,0xda,0x60,0x29,0x62,0x03,0x11,0xb9,0xdc,0x42,0x64,0x6e,0x6f,0xb5,0x6f,0x07,0xf1,0x2c,0xa2,0x57,0x38,0x3f,0xf9,0xf1,0x71,0x49,0xea,0x72,0x9d,0x22,0x0c,0xda,0x74,0xcd,0x79,0x67,0x20,0x76,0x7e,0x78,0x12,0x49,0x9f,0x56,0x84,0x3f,0x23,0xa4,0x6a,0xdd,0xd1,0x4a,0x44,0x4f,0x0d,0x4c,0x34,0x2c,0x97,0xf8,0xad,0x89,0xc6,0x56,0x97,0xf2,0xd2,0x83,0x61,0x6c,0xfd,0x27,0x1f,0xfa,0xc7,0xd3,0x9a,0xc1,0x01,0x03,0x33,0x52,0xd1,0xa2,0x68,0x6b,0x71,0xa6,0xe4,0x97,0x0c,0x10,0x94,0xaf,0xac,0xd6,0x94,0xf6,0x4b,0xab,0xfb,0x44,0x0f,0x46,0xb3,0x36,0x71};
//uint8_t n[] = {0xf5,0x4a,0xef,0x85,0x1a,0xe1,0x86,0xb8,0xb9,0xe0,0x42,0x2e,0x94,0x75,0x99,0x60,0xd3,0xc8,0x81,0x29,0x39,0x2d,0x11,0x2d,0xe4,0xf4,0xb6,0xe6,0xbc,0xa9,0x86,0x4b,0xd3,0x79,0xea,0xbc,0x62,0xe4,0x8f,0x9f,0x81,0x43,0x2b,0x49,0x68,0x48,0x06,0xed,0x6a,0xb2,0x49,0xbd,0x97,0x5a,0x51,0x2c,0xfc,0xb3,0x2e,0xec,0x1a,0x24,0x5f,0xa2,0x32,0xb4,0x2a,0x38,0x2b,0x01,0x0c,0x85,0x5c,0xfb,0xdc,0x86,0x5f,0x44,0x78,0x26,0x64,0xdf,0xfb,0x6e,0x4a,0x54,0x4f,0xe4,0x40,0x56,0x94,0x4d,0x74,0x81,0x73,0xc1,0x83,0x9e,0x4d,0xb1,0x66,0xdc,0x96,0xb8,0x84,0x00,0x56,0x27,0x36,0x91,0xeb,0x0e,0x1a,0x1c,0x8f,0x94,0x47,0x25,0x1e,0x3c,0x93,0xf9,0xc5,0x44,0x3e,0x07,0xb7,0x61};
uint8_t base_arr[] = {0xE0,0x0C,0x0A,0x0A,0x64,0x52,0xC3,0x48,0x55,0x7B,0x94,0xD1,0xB5,0xF8,0x69,0x34,0x5B,0xB7,0x1B,0xF7,0x74,0xFE,0x29,0x65,0x14,0xD7,0x1E,0x85,0xE2,0x2E,0x32,0xDC,0x0A,0xFA,0xCD,0x55,0x16,0x8B,0x89,0xF8,0x85,0xC5,0xD9,0xF5,0x97,0x1A,0x6E,0x01,0x90,0xD4,0x52,0x7D,0xAC,0x1A,0x47,0xCC,0x47,0xBF,0x8D,0x2E,0x22,0x70,0xC0,0xBD,0x4F,0x1E,0x57,0x5F,0xC2,0x5A,0xC4,0xEB,0x84,0x23,0x84,0x05,0x77,0x85,0x05,0xB9,0xC4,0x7E,0x92,0x86,0xAD,0xB7,0xDE,0xA4,0x32,0x4D,0x5F,0xCD,0x8C,0x5D,0xC2,0x9E,0xDD,0x99,0x1C,0xD9,0xE5,0x25,0x75,0x24,0xD1,0x79,0x62,0x30,0x30,0xEB,0x94,0xEF,0xA2,0xF0,0xBB,0xA9,0xFC,0xC6,0x91,0x27,0xD1,0xFF,0xAC,0xFC,0x29,0xC7,0xED,0x99};
uint8_t publexp_arr[] = {0x71,0x36,0xB3,0x46,0x0F,0x44,0xFB,0xAB,0x4B,0xF6,0x94,0xD6,0xAC,0xAF,0x94,0x10,0x0C,0x97,0xE4,0xA6,0x71,0x6B,0x68,0xA2,0xD1,0x52,0x33,0x03,0x01,0xC1,0x9A,0xD3,0xC7,0xFA,0x1F,0x27,0xFD,0x6C,0x61,0x83,0xD2,0xF2,0x97,0x56,0xC6,0x89,0xAD,0xF8,0x97,0x2C,0x34,0x4C,0x0D,0x4F,0x44,0x4A,0xD1,0xDD,0x6A,0xA4,0x23,0x3F,0x84,0x56,0x9F,0x49,0x12,0x78,0x7E,0x76,0x20,0x67,0x79,0xCD,0x74,0xDA,0x0C,0x22,0x9D,0x72,0xEA,0x49,0x71,0xF1,0xF9,0x3F,0x38,0x57,0xA2,0x2C,0xF1,0x07,0x6F,0xB5,0x6F,0x6E,0x64,0x42,0xDC,0xB9,0x11,0x03,0x62,0x29,0x60,0xDA,0x8F,0x63,0x28,0x82,0xAD,0xC2,0x04,0xBC,0xB6,0x94,0x7F,0x1F,0x32,0x50,0x07,0x7C,0xD8,0x9D,0xF1,0x0C,0x02,0x10};
uint8_t modulus_arr[] = {0x61,0xB7,0x07,0x3E,0x44,0xC5,0xF9,0x93,0x3C,0x1E,0x25,0x47,0x94,0x8F,0x1C,0x1A,0x0E,0xEB,0x91,0x36,0x27,0x56,0x00,0x84,0xB8,0x96,0xDC,0x66,0xB1,0x4D,0x9E,0x83,0xC1,0x73,0x81,0x74,0x4D,0x94,0x56,0x40,0xE4,0x4F,0x54,0x4A,0x6E,0xFB,0xDF,0x64,0x26,0x78,0x44,0x5F,0x86,0xDC,0xFB,0x5C,0x85,0x0C,0x01,0x2B,0x38,0x2A,0xB4,0x32,0xA2,0x5F,0x24,0x1A,0xEC,0x2E,0xB3,0xFC,0x2C,0x51,0x5A,0x97,0xBD,0x49,0xB2,0x6A,0xED,0x06,0x48,0x68,0x49,0x2B,0x43,0x81,0x9F,0x8F,0xE4,0x62,0xBC,0xEA,0x79,0xD3,0x4B,0x86,0xA9,0xBC,0xE6,0xB6,0xF4,0xE4,0x2D,0x11,0x2D,0x39,0x29,0x81,0xC8,0xD3,0x60,0x99,0x75,0x94,0x2E,0x42,0xE0,0xB9,0xB8,0x86,0xE1,0x1A,0x85,0xEF,0x4A,0xF5};

//uint8_t Mbar[] = {0x05,0xD1,0xC8,0x6B,0x1D,0x4F,0x24,0xE5,0xB4,0x18,0x01,0x7A,0x35,0x8D,0xB2,0x9D,0x8B,0xEF,0x60,0x0B,0xAE,0x0C,0xA6,0x35,0x24,0xBE,0x7E,0x57,0x81,0x22,0xD7,0xBF,0x3C,0x12,0x16,0x56,0x70,0xA2,0x8B,0xFA,0xF7,0xCF,0xA8,0xF8,0xE7,0xB4,0xAB,0x2F,0xF0,0x6A,0x83,0x8D,0xF3,0xE8,0x3F,0x8C,0xE2,0x1E,0x5C,0xAD,0xD3,0xB0,0xFE,0x3A,0xE9,0x1C,0x4C,0x90,0x26,0x66,0x96,0x96,0x57,0xA3,0x5E,0x3C,0x69,0x8C,0x4A,0x73,0xB4,0x38,0x99,0x6C,0x44,0xC9,0x70,0x35,0x31,0xC5,0x9D,0x25,0x51,0xF3,0x4A,0xC4,0x1C,0xEA,0x7B,0xFE,0x8E,0x8B,0xDC,0xB6,0x55,0x74,0x37,0x90,0xF8,0x7A,0xCF,0x18,0xEA,0x68,0xBE,0x78,0xF0,0xF9,0xA0,0x6F,0xD3,0x1F,0xF4,0x84,0x1D,0xBC,0x4F,0x25};
//uint8_t xbar[] = {0x0A,0xB5,0x10,0x7A,0xE5,0x1E,0x79,0x47,0x46,0x1F,0xBD,0xD1,0x6B,0x8A,0x66,0x9F,0x2C,0x37,0x7E,0xD6,0xC6,0xD2,0xEE,0xD2,0x1B,0x0B,0x49,0x19,0x43,0x56,0x79,0xB4,0x2C,0x86,0x15,0x43,0x9D,0x1B,0x70,0x60,0x7E,0xBC,0xD4,0xB6,0x97,0xB7,0xF9,0x12,0x95,0x4D,0xB6,0x42,0x68,0xA5,0xAE,0xD3,0x03,0x4C,0xD1,0x13,0xE5,0xDB,0xA0,0x5D,0xCD,0x4B,0xD5,0xC7,0xD4,0xFE,0xF3,0x7A,0xA3,0x04,0x23,0x79,0xA0,0xBB,0x87,0xD9,0x9B,0x20,0x04,0x91,0xB5,0xAB,0xB0,0x1B,0xBF,0xA9,0x6B,0xB2,0x8B,0x7E,0x8C,0x3E,0x7C,0x61,0xB2,0x4E,0x99,0x23,0x69,0x47,0x7B,0xFF,0xA9,0xD8,0xC9,0x6E,0x14,0xF1,0xE5,0xE3,0x70,0x6B,0xB8,0xDA,0xE1,0xC3,0x6C,0x06,0x3A,0xBB,0xC1,0xF8,0x48,0x9F};


// Data buffers, with matching sizes to memory spaces
XWsrsa1024_Base_v base;
XWsrsa1024_Publexp_v publexp;
XWsrsa1024_Modulus_v modulus;
XWsrsa1024_Result_v ansv;

static void startwait(void);

int32_t rsa_init(void)
{
	//	 Lookup device configuration
	xrsamodexpCfgPtr = XWsrsa1024_LookupConfig(XPAR_WSRSA1024_0_DEVICE_ID);
	if (!xrsamodexpCfgPtr) {
		print("ERROR: Lookup of rsa accelerator configuration failed!\n\r");
		return FAIL;
	}

	// initialize device
	int status = XWsrsa1024_CfgInitialize(&xrsamodexp, xrsamodexpCfgPtr);
	if (status != XST_SUCCESS) {
		print("ERROR: could not initialize rsamodexp accelerator!\n\r");
		return FAIL;
	}

	XWsrsa1024_DisableAutoRestart(&xrsamodexp);


#if PRINTARGS==1
	xil_printf("Backwards Args:\n");
	xil_printf("  uint8_t M[] = {0x%02X",base_arr[RSA_NUM_BYTES-1]);
	for (int i=RSA_NUM_BYTES-2; i>=0; i--)
		xil_printf(",0x%02X",base_arr[i]);
	xil_printf("};\n");

	xil_printf("  uint8_t e[] = {0x%02X",publexp_arr[RSA_NUM_BYTES-1]);
	for (int i=RSA_NUM_BYTES-2; i>=0; i--)
		xil_printf(",0x%02X",publexp_arr[i]);
	xil_printf("};\n");

	xil_printf("  uint8_t n[] = {0x%02X",modulus_arr[RSA_NUM_BYTES-1]);
	for (int i=RSA_NUM_BYTES-2; i>=0; i--)
		xil_printf(",0x%02X",modulus_arr[i]);
	xil_printf("};\n\n");

#endif

	xil_printf("Initialized\n");
	return SUCCESS;
}


int32_t rsa_test(void)
{
	print("Hello, world!\n\n");

	uint32_t ret = rsa_init();
	if (ret)
		xil_printf("RSA init error!\n");

	// Copy operands values into local memory structs
	memcpy(&base, base_arr, RSA_NUM_BYTES);
	memcpy(&publexp, publexp_arr, RSA_NUM_BYTES);
	memcpy(&modulus, modulus_arr, RSA_NUM_BYTES);

	// zero out local destination struct
	memset(&ansv, 0, sizeof(XWsrsa1024_Result_v));

	// write Values to AXI memory
	XWsrsa1024_Set_base_V(&xrsamodexp, base);
	XWsrsa1024_Set_publexp_V(&xrsamodexp, publexp);
	XWsrsa1024_Set_modulus_V(&xrsamodexp, modulus);

	// Set mode to encrypt
	XWsrsa1024_Set_mode(&xrsamodexp,ENCRYPT);

	// start block
	startwait();

	// read back data
	ansv = XWsrsa1024_Get_result_V(&xrsamodexp);

	uint8_t *p = (uint8_t*)&ansv;
	xil_printf("answer = 0x");
	for (int i=sizeof(ansv)-1; i>=0; i--)
	{
		xil_printf("%0X",*p++);
	}
	xil_printf("\n");

	u32 status = memcmp(&ansv, &golden_ans, sizeof(golden_ans));
	if (status != 0)
		xil_printf("ERROR, ANSWER NOT CORRECT\n");
	else
		xil_printf("SUCCESS!\n");

	return 0;
}


static void startwait(void)
{
	XWsrsa1024_Start(&xrsamodexp);
	// wait for result
	while( !XWsrsa1024_IsDone(&xrsamodexp));
}
